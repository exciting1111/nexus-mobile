diff --git a/android/build.gradle b/android/build.gradle
index 4f27de1c3d930a4cc8b7bc4232aef280c8bcb1c4..ad67a1b3b807f304a99f9604de06757c3777e074 100755
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -70,9 +70,9 @@ dependencies {
   // Needed for BiometricPrompt in androidx.biometric
   implementation "androidx.fragment:fragment:1.3.2@aar"
 
-  /* version higher 1.1.3 has problems with included soloader packages,
-      https://github.com/facebook/conceal/releases */
-  implementation "com.facebook.conceal:conceal:1.1.3@aar"
+  // /* version higher 1.1.3 has problems with included soloader packages,
+  //     https://github.com/facebook/conceal/releases */
+  // implementation "com.facebook.conceal:conceal:1.1.3@aar"
 
   /* Unit Testing Frameworks */
   testImplementation 'junit:junit:4.13.2'
diff --git a/android/src/main/java/com/oblador/keychain/KeychainModule.java b/android/src/main/java/com/oblador/keychain/KeychainModule.java
index 9413000ccfbf401dbf8406a260bfe3402b9191dd..354bc3156c91111b8438af2d452e29e62f775eb5 100644
--- a/android/src/main/java/com/oblador/keychain/KeychainModule.java
+++ b/android/src/main/java/com/oblador/keychain/KeychainModule.java
@@ -1,6 +1,8 @@
 package com.oblador.keychain;
 
+import android.content.Context;
 import android.os.Build;
+import android.os.Bundle;
 import android.text.TextUtils;
 import android.util.Log;
 
@@ -9,7 +11,11 @@ import androidx.annotation.Nullable;
 import androidx.annotation.StringDef;
 import androidx.biometric.BiometricManager;
 import androidx.biometric.BiometricPrompt.PromptInfo;
+import android.security.keystore.UserNotAuthenticatedException;
 
+import com.facebook.react.bridge.ActivityEventListener;
+import com.facebook.react.bridge.Arguments;
+import com.facebook.react.bridge.BaseActivityEventListener;
 import com.facebook.react.bridge.Arguments;
 import com.facebook.react.bridge.Promise;
 import com.facebook.react.bridge.ReactApplicationContext;
@@ -22,7 +28,7 @@ import com.oblador.keychain.cipherStorage.CipherStorage;
 import com.oblador.keychain.cipherStorage.CipherStorage.DecryptionResult;
 import com.oblador.keychain.cipherStorage.CipherStorage.EncryptionResult;
 import com.oblador.keychain.cipherStorage.CipherStorageBase;
-import com.oblador.keychain.cipherStorage.CipherStorageFacebookConceal;
+// import com.oblador.keychain.cipherStorage.CipherStorageFacebookConceal;
 import com.oblador.keychain.cipherStorage.CipherStorageKeystoreAesCbc;
 import com.oblador.keychain.cipherStorage.CipherStorageKeystoreRsaEcb;
 import com.oblador.keychain.decryptionHandler.DecryptionResultHandler;
@@ -36,10 +42,14 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
 import javax.crypto.Cipher;
+import android.app.Activity;
+import android.app.KeyguardManager;
+import android.content.Intent;
 
 import static com.facebook.react.bridge.Arguments.makeNativeArray;
 
@@ -52,9 +62,25 @@ public class KeychainModule extends ReactContextBaseJavaModule {
   public static final String IRIS_SUPPORTED_NAME = "Iris";
   public static final String EMPTY_STRING = "";
   public static final String WARMING_UP_ALIAS = "warmingUp";
+  public static final String E_CRYPTO_FAILED = "E_CRYPTO_FAILED";
+  public static final String E_USER_AUTH_FAILED = "E_USER_DIDNT_AUTH";
 
   private static final String LOG_TAG = KeychainModule.class.getSimpleName();
 
+  private KeyguardManager mKeyguardManager;
+  final ReactApplicationContext mReactContext;
+
+  private String mUsername;
+  private String mPassword;
+  private Promise mPromise;
+  private ReadableMap mOptions;
+  private String mCurrentAction;
+
+  public static final String AUTH_PROMPT_TITLE_KEY = "authenticationPromptTitle";
+  public static final String AUTH_PROMPT_DESC_KEY = "authenticationPromptDesc";
+
+  private static final int REQUEST_CODE_CONFIRM_DEVICE_CREDENTIALS = 42;
+
   @StringDef({AccessControl.NONE
     , AccessControl.USER_PRESENCE
     , AccessControl.BIOMETRY_ANY
@@ -63,6 +89,7 @@ public class KeychainModule extends ReactContextBaseJavaModule {
     , AccessControl.APPLICATION_PASSWORD
     , AccessControl.BIOMETRY_ANY_OR_DEVICE_PASSCODE
     , AccessControl.BIOMETRY_CURRENT_SET_OR_DEVICE_PASSCODE})
+
   @interface AccessControl {
     String NONE = "None";
     String USER_PRESENCE = "UserPresence";
@@ -110,7 +137,7 @@ public class KeychainModule extends ReactContextBaseJavaModule {
   /** Supported ciphers. */
   @StringDef({KnownCiphers.FB, KnownCiphers.AES, KnownCiphers.RSA})
   public @interface KnownCiphers {
-    /** Facebook conceal compatibility lib in use. */
+    /** Facebook conceal compatibility lib in use. {@deprecated} */
     String FB = "FacebookConceal";
     /** AES encryption. */
     String AES = "KeystoreAESCBC";
@@ -127,7 +154,7 @@ public class KeychainModule extends ReactContextBaseJavaModule {
   //endregion
 
   //region Members
-  /** Name-to-instance lookup  map. */
+  /** Name-to-instance lookup map. */
   private final Map<String, CipherStorage> cipherStorageMap = new HashMap<>();
   /** Shared preferences storage. */
   private final PrefsStorage prefsStorage;
@@ -138,15 +165,19 @@ public class KeychainModule extends ReactContextBaseJavaModule {
   /** Default constructor. */
   public KeychainModule(@NonNull final ReactApplicationContext reactContext) {
     super(reactContext);
+    mReactContext = reactContext;
+
     prefsStorage = new PrefsStorage(reactContext);
 
-    addCipherStorageToMap(new CipherStorageFacebookConceal(reactContext));
+    // addCipherStorageToMap(new CipherStorageFacebookConceal(reactContext));
     addCipherStorageToMap(new CipherStorageKeystoreAesCbc());
 
     // we have a references to newer api that will fail load of app classes in old androids OS
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
       addCipherStorageToMap(new CipherStorageKeystoreRsaEcb());
     }
+
+    reactContext.addActivityEventListener(mActivityEventListener);
   }
 
   /** Allow initialization in chain. */
@@ -171,7 +202,7 @@ public class KeychainModule extends ReactContextBaseJavaModule {
       final Cipher instance = best.getCachedInstance();
       final boolean isSecure = best.supportsSecureHardware();
       final SecurityLevel requiredLevel = isSecure ? SecurityLevel.SECURE_HARDWARE : SecurityLevel.SECURE_SOFTWARE;
-      best.generateKeyAndStoreUnderAlias(WARMING_UP_ALIAS, requiredLevel);
+      best.generateKeyAndStoreUnderAlias(WARMING_UP_ALIAS, requiredLevel, false);
       best.getKeyStoreAndLoad();
 
       Log.v(KEYCHAIN_MODULE, "warming up takes: " +
@@ -206,6 +237,50 @@ public class KeychainModule extends ReactContextBaseJavaModule {
   }
   //endregion
 
+  private final ActivityEventListener mActivityEventListener = new BaseActivityEventListener() {
+    @Override
+    public void onActivityResult(Activity activity, int requestCode, int resultCode, Intent intent) {
+      if (requestCode == REQUEST_CODE_CONFIRM_DEVICE_CREDENTIALS) {
+        // Challenge completed, proceed with using cipher
+        if (resultCode == Activity.RESULT_OK) {
+          if (Objects.equals(mCurrentAction, "set")) {
+            setGenericPasswordForOptions(mOptions, mUsername, mPassword, mPromise);
+          } else {
+            getGenericPasswordForOptions(mOptions, mPromise);
+          }
+        } else {
+          // The user canceled or didnâ€™t complete the lock screen
+          // operation. Go to error/cancellation flow.
+          mPromise.reject(E_USER_AUTH_FAILED, new Exception("Error: Cancel"));
+        }
+      }
+
+      mCurrentAction = null;
+      mOptions = null;
+      mUsername = null;
+      mPassword = null;
+    }
+  };
+
+  public void handleUserNotAuthenticatedException(Promise promise) {
+    String authPromptTitle = null;
+    String authPromptDesc = null;
+    if (mOptions != null) {
+      if (mOptions.hasKey(AUTH_PROMPT_TITLE_KEY)) {
+        authPromptTitle = mOptions.getString(AUTH_PROMPT_TITLE_KEY);
+      }
+
+      if (mOptions.hasKey(AUTH_PROMPT_DESC_KEY)) {
+        authPromptDesc = mOptions.getString(AUTH_PROMPT_DESC_KEY);
+      }
+    }
+    Intent intent = mKeyguardManager.createConfirmDeviceCredentialIntent(authPromptTitle, authPromptDesc);
+    if (intent != null) {
+      Activity currentActivity = getCurrentActivity();
+      Objects.requireNonNull(currentActivity).startActivityForResult(intent, REQUEST_CODE_CONFIRM_DEVICE_CREDENTIALS);
+    }
+  }
+
   //region React Methods
   protected void setGenericPassword(@NonNull final String alias,
                                     @NonNull final String username,
@@ -213,6 +288,8 @@ public class KeychainModule extends ReactContextBaseJavaModule {
                                     @Nullable final ReadableMap options,
                                     @NonNull final Promise promise) {
     try {
+      mKeyguardManager = (KeyguardManager) mReactContext.getSystemService(mReactContext.KEYGUARD_SERVICE);
+
       throwIfEmptyLoginPassword(username, password);
 
       final SecurityLevel level = getSecurityLevelOrDefault(options);
@@ -220,7 +297,8 @@ public class KeychainModule extends ReactContextBaseJavaModule {
 
       throwIfInsufficientLevel(storage, level);
 
-      final EncryptionResult result = storage.encrypt(alias, username, password, level);
+      final String accessControl = getAccessControlOrDefault(options);
+      final EncryptionResult result = storage.encrypt(alias, username, password, level, mKeyguardManager.isKeyguardSecure() ? accessControl : null);
       prefsStorage.storeEncryptedEntry(alias, result);
 
       final WritableMap results = Arguments.createMap();
@@ -233,9 +311,17 @@ public class KeychainModule extends ReactContextBaseJavaModule {
 
       promise.reject(Errors.E_EMPTY_PARAMETERS, e);
     } catch (CryptoFailedException e) {
-      Log.e(KEYCHAIN_MODULE, e.getMessage(), e);
-
-      promise.reject(Errors.E_CRYPTO_FAILED, e);
+      if (e.getCause() != null && Objects.equals(e.getCause().getMessage(), "User not authenticated")) {
+        mPromise = promise;
+        mUsername = username;
+        mPassword = password;
+        mOptions = options;
+        mCurrentAction = "set";
+        this.handleUserNotAuthenticatedException(promise);
+      } else {
+        Log.e(KEYCHAIN_MODULE, e.getMessage());
+        promise.reject(E_CRYPTO_FAILED, e);
+      }
     } catch (Throwable fail) {
       Log.e(KEYCHAIN_MODULE, fail.getMessage(), fail);
 
@@ -288,6 +374,11 @@ public class KeychainModule extends ReactContextBaseJavaModule {
 
       final String storageName = resultSet.cipherStorageName;
       final String rules = getSecurityRulesOrDefault(options);
+
+      if (mKeyguardManager == null) {
+        mKeyguardManager = (KeyguardManager) mReactContext.getSystemService(mReactContext.KEYGUARD_SERVICE);
+      }
+
       final PromptInfo promptInfo = getPromptInfo(options);
 
       CipherStorage cipher = null;
@@ -317,9 +408,15 @@ public class KeychainModule extends ReactContextBaseJavaModule {
 
       promise.reject(Errors.E_KEYSTORE_ACCESS_ERROR, e);
     } catch (CryptoFailedException e) {
-      Log.e(KEYCHAIN_MODULE, e.getMessage());
-
-      promise.reject(Errors.E_CRYPTO_FAILED, e);
+      if (e.getCause() != null && e.getCause().getMessage() == "User not authenticated") {
+        mOptions = options;
+        mPromise = promise;
+        mCurrentAction = "get";
+        this.handleUserNotAuthenticatedException(promise);
+      } else {
+        Log.e(KEYCHAIN_MODULE, e.getMessage());
+        promise.reject(E_CRYPTO_FAILED, e);
+      }
     } catch (Throwable fail) {
       Log.e(KEYCHAIN_MODULE, fail.getMessage(), fail);
 
@@ -557,7 +654,6 @@ public class KeychainModule extends ReactContextBaseJavaModule {
     return accessControl;
   }
 
-
   /** Get security level from options or fallback {@link SecurityLevel#ANY} value. */
   @NonNull
   private static SecurityLevel getSecurityLevelOrDefault(@Nullable final ReadableMap options) {
@@ -674,7 +770,7 @@ public class KeychainModule extends ReactContextBaseJavaModule {
                                            @NonNull final CipherStorage storage,
                                            @NonNull final ResultSet resultSet,
                                            @NonNull final PromptInfo promptInfo)
-    throws CryptoFailedException {
+  throws CryptoFailedException {
     final DecryptionResultHandler handler = getInteractiveHandler(storage, promptInfo);
     storage.decrypt(handler, alias, resultSet.username, resultSet.password, SecurityLevel.ANY);
 
@@ -706,7 +802,7 @@ public class KeychainModule extends ReactContextBaseJavaModule {
     // storage should be as safe as the old one.
     final EncryptionResult encryptionResult = newCipherStorage.encrypt(
       service, decryptionResult.username, decryptionResult.password,
-      decryptionResult.getSecurityLevel());
+      decryptionResult.getSecurityLevel(), null);
 
     // store the encryption result
     prefsStorage.storeEncryptedEntry(service, encryptionResult);
diff --git a/android/src/main/java/com/oblador/keychain/PrefsStorage.java b/android/src/main/java/com/oblador/keychain/PrefsStorage.java
index b7ecd5141e43cd65b4e80d0c9677e1dc3b421092..5a67976fe06e52a83853d2102e70b3411a097f82 100644
--- a/android/src/main/java/com/oblador/keychain/PrefsStorage.java
+++ b/android/src/main/java/com/oblador/keychain/PrefsStorage.java
@@ -51,7 +51,7 @@ public class PrefsStorage {
     if (cipherStorageName == null) {
       // If the CipherStorage name is not found, we assume it is because the entry was written by an older
       // version of this library. The older version used Facebook Conceal, so we default to that.
-      cipherStorageName = KnownCiphers.FB;
+      cipherStorageName = KnownCiphers.RSA;
     }
 
     return new ResultSet(cipherStorageName, bytesForUsername, bytesForPassword);
diff --git a/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorage.java b/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorage.java
index 5d7817ff38d00edce5930b3e7976e785705794bc..3588a121b3fc2612692334c67640aa39cf70843c 100644
--- a/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorage.java
+++ b/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorage.java
@@ -83,7 +83,8 @@ public interface CipherStorage {
   EncryptionResult encrypt(@NonNull final String alias,
                            @NonNull final String username,
                            @NonNull final String password,
-                           @NonNull final SecurityLevel level)
+                           @NonNull final SecurityLevel level,
+                           String accessControl)
     throws CryptoFailedException;
 
   /**
diff --git a/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageBase.java b/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageBase.java
index 5c82167c354de8b6a30e676b06a8594040fbc62f..4c5f1540797f5e098a2aa8577098fbce555eda85 100644
--- a/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageBase.java
+++ b/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageBase.java
@@ -165,12 +165,12 @@ abstract public class CipherStorageBase implements CipherStorage {
 
   /** Get encryption algorithm specification builder instance. */
   @NonNull
-  protected abstract KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias)
+  protected abstract KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias, Boolean getKeyGenSpecBuilder)
     throws GeneralSecurityException;
 
   /** Get encryption algorithm specification builder instance. */
   @NonNull
-  protected abstract KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias, @NonNull final boolean isforTesting)
+  protected abstract KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias, @NonNull final boolean isforTesting, Boolean getKeyGenSpecBuilder)
     throws GeneralSecurityException;
 
 
@@ -223,7 +223,8 @@ abstract public class CipherStorageBase implements CipherStorage {
   @NonNull
   protected Key extractGeneratedKey(@NonNull final String safeAlias,
                                     @NonNull final SecurityLevel level,
-                                    @NonNull final AtomicInteger retries)
+                                    @NonNull final AtomicInteger retries,
+                                    Boolean requireAuthentication)
     throws GeneralSecurityException {
     Key key;
 
@@ -232,7 +233,7 @@ abstract public class CipherStorageBase implements CipherStorage {
 
       // if key is not available yet, try to generate the strongest possible
       if (!keyStore.containsAlias(safeAlias)) {
-        generateKeyAndStoreUnderAlias(safeAlias, level);
+        generateKeyAndStoreUnderAlias(safeAlias, level, requireAuthentication);
       }
 
       // throw exception if cannot extract key in several retries
@@ -396,7 +397,8 @@ abstract public class CipherStorageBase implements CipherStorage {
 
   /** Get the most secured keystore */
   public void generateKeyAndStoreUnderAlias(@NonNull final String alias,
-                                            @NonNull final SecurityLevel requiredLevel)
+                                            @NonNull final SecurityLevel requiredLevel,
+                                            Boolean requireAuthentication)
     throws GeneralSecurityException {
 
     // Firstly, try to generate the key as safe as possible (strongbox).
@@ -410,7 +412,7 @@ abstract public class CipherStorageBase implements CipherStorage {
         if (null == isStrongboxAvailable) isStrongboxAvailable = new AtomicBoolean(false);
 
         try {
-          secretKey = tryGenerateStrongBoxSecurityKey(alias);
+          secretKey = tryGenerateStrongBoxSecurityKey(alias, requireAuthentication);
 
           isStrongboxAvailable.set(true);
         } catch (GeneralSecurityException | ProviderException ex) {
@@ -423,7 +425,7 @@ abstract public class CipherStorageBase implements CipherStorage {
     // (it still might be generated in hardware, but not in StrongBox)
     if (null == secretKey || !isStrongboxAvailable.get()) {
       try {
-        secretKey = tryGenerateRegularSecurityKey(alias);
+        secretKey = tryGenerateRegularSecurityKey(alias, requireAuthentication);
       } catch (GeneralSecurityException fail) {
         Log.e(LOG_TAG, "Regular security storage is not available.", fail);
         throw fail;
@@ -437,18 +439,18 @@ abstract public class CipherStorageBase implements CipherStorage {
 
   /** Try to get secured keystore instance. */
   @NonNull
-  protected Key tryGenerateRegularSecurityKey(@NonNull final String alias) throws GeneralSecurityException {
-    return tryGenerateRegularSecurityKey(alias, false);
+  protected Key tryGenerateRegularSecurityKey(@NonNull final String alias, Boolean requireAuthentication) throws GeneralSecurityException {
+    return tryGenerateRegularSecurityKey(alias, false, requireAuthentication);
   }
   @NonNull
-  protected Key tryGenerateRegularSecurityKey(@NonNull final String alias, @NonNull final boolean isForTesting)
+  protected Key tryGenerateRegularSecurityKey(@NonNull final String alias, @NonNull final boolean isForTesting, Boolean requireAuthentication)
     throws GeneralSecurityException {
     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
       throw new KeyStoreAccessException("Regular security keystore is not supported " +
         "for old API" + Build.VERSION.SDK_INT + ".");
     }
 
-    final KeyGenParameterSpec specification = getKeyGenSpecBuilder(alias, isForTesting)
+    final KeyGenParameterSpec specification = getKeyGenSpecBuilder(alias, isForTesting, requireAuthentication)
       .build();
 
     return generateKey(specification);
@@ -456,19 +458,19 @@ abstract public class CipherStorageBase implements CipherStorage {
 
   /** Try to get strong secured keystore instance. (StrongBox security chip) */
   @NonNull
-  protected Key tryGenerateStrongBoxSecurityKey(@NonNull final String alias) throws GeneralSecurityException{
-    return tryGenerateStrongBoxSecurityKey(alias,false);
+  protected Key tryGenerateStrongBoxSecurityKey(@NonNull final String alias, Boolean requireAuthentication) throws GeneralSecurityException{
+    return tryGenerateStrongBoxSecurityKey(alias, false, requireAuthentication);
   }
 
   @NonNull
-  protected Key tryGenerateStrongBoxSecurityKey(@NonNull final String alias, @NonNull final boolean isForTesting)
+  protected Key tryGenerateStrongBoxSecurityKey(@NonNull final String alias, @NonNull final boolean isForTesting, Boolean requireAuthentication)
     throws GeneralSecurityException {
     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.P) {
       throw new KeyStoreAccessException("Strong box security keystore is not supported " +
         "for old API" + Build.VERSION.SDK_INT + ".");
     }
 
-    final KeyGenParameterSpec specification = getKeyGenSpecBuilder(alias, isForTesting)
+    final KeyGenParameterSpec specification = getKeyGenSpecBuilder(alias, isForTesting, requireAuthentication)
       .setIsStrongBoxBacked(true)
       .build();
 
@@ -596,7 +598,7 @@ abstract public class CipherStorageBase implements CipherStorage {
     public final Key key;
 
     public SelfDestroyKey(@NonNull final String name) throws GeneralSecurityException {
-      this(name, tryGenerateRegularSecurityKey(name, true));
+      this(name, tryGenerateRegularSecurityKey(name, false));
     }
 
     public SelfDestroyKey(@NonNull final String name, @NonNull final Key key) {
diff --git a/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageFacebookConceal.java b/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageFacebookConceal.java
deleted file mode 100644
index 0dfc55a80b2de898511d35b3776ac953defd8767..0000000000000000000000000000000000000000
--- a/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageFacebookConceal.java
+++ /dev/null
@@ -1,214 +0,0 @@
-package com.oblador.keychain.cipherStorage;
-
-import android.os.Build;
-import android.security.keystore.KeyGenParameterSpec;
-import android.security.keystore.KeyInfo;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-
-import com.facebook.android.crypto.keychain.AndroidConceal;
-import com.facebook.android.crypto.keychain.SharedPrefsBackedKeyChain;
-import com.facebook.crypto.Crypto;
-import com.facebook.crypto.CryptoConfig;
-import com.facebook.crypto.Entity;
-import com.facebook.crypto.keychain.KeyChain;
-import com.facebook.react.bridge.AssertionException;
-import com.facebook.react.bridge.ReactApplicationContext;
-import com.oblador.keychain.KeychainModule.KnownCiphers;
-import com.oblador.keychain.SecurityLevel;
-import com.oblador.keychain.decryptionHandler.DecryptionResultHandler;
-import com.oblador.keychain.exceptions.CryptoFailedException;
-
-import java.security.GeneralSecurityException;
-import java.security.Key;
-
-/**
- * @see <a href="https://github.com/facebook/conceal">Conceal Project</a>
- * @see <a href="https://medium.com/@ssaurel/make-fast-cryptographic-operations-on-android-with-conceal-77a751e89b8e">Fast Cryptographics</a>
- */
-@SuppressWarnings({"unused", "WeakerAccess"})
-public class CipherStorageFacebookConceal extends CipherStorageBase {
-  public static final String KEYCHAIN_DATA = "RN_KEYCHAIN";
-
-  private final Crypto crypto;
-
-  public CipherStorageFacebookConceal(@NonNull final ReactApplicationContext reactContext) {
-    KeyChain keyChain = new SharedPrefsBackedKeyChain(reactContext, CryptoConfig.KEY_256);
-
-    this.crypto = AndroidConceal.get().createDefaultCrypto(keyChain);
-  }
-
-  //region Configuration
-  @Override
-  public String getCipherStorageName() {
-    return KnownCiphers.FB;
-  }
-
-  @Override
-  public int getMinSupportedApiLevel() {
-    return Build.VERSION_CODES.JELLY_BEAN;
-  }
-
-  @Override
-  public SecurityLevel securityLevel() {
-    return SecurityLevel.ANY;
-  }
-
-  @Override
-  public boolean supportsSecureHardware() {
-    return false;
-  }
-
-  @Override
-  public boolean isBiometrySupported() {
-    return false;
-  }
-  //endregion
-
-  //region Overrides
-  @Override
-  @NonNull
-  public EncryptionResult encrypt(@NonNull final String alias,
-                                  @NonNull final String username,
-                                  @NonNull final String password,
-                                  @NonNull final SecurityLevel level)
-    throws CryptoFailedException {
-
-    throwIfInsufficientLevel(level);
-    throwIfNoCryptoAvailable();
-
-    final Entity usernameEntity = createUsernameEntity(alias);
-    final Entity passwordEntity = createPasswordEntity(alias);
-
-    try {
-      final byte[] encryptedUsername = crypto.encrypt(username.getBytes(UTF8), usernameEntity);
-      final byte[] encryptedPassword = crypto.encrypt(password.getBytes(UTF8), passwordEntity);
-
-      return new EncryptionResult(
-        encryptedUsername,
-        encryptedPassword,
-        this);
-    } catch (Throwable fail) {
-      throw new CryptoFailedException("Encryption failed for alias: " + alias, fail);
-    }
-  }
-
-  @NonNull
-  @Override
-  public DecryptionResult decrypt(@NonNull final String alias,
-                                  @NonNull final byte[] username,
-                                  @NonNull final byte[] password,
-                                  @NonNull final SecurityLevel level)
-    throws CryptoFailedException {
-
-    throwIfInsufficientLevel(level);
-    throwIfNoCryptoAvailable();
-
-    final Entity usernameEntity = createUsernameEntity(alias);
-    final Entity passwordEntity = createPasswordEntity(alias);
-
-    try {
-      final byte[] decryptedUsername = crypto.decrypt(username, usernameEntity);
-      final byte[] decryptedPassword = crypto.decrypt(password, passwordEntity);
-
-      return new DecryptionResult(
-        new String(decryptedUsername, UTF8),
-        new String(decryptedPassword, UTF8),
-        SecurityLevel.ANY);
-    } catch (Throwable fail) {
-      throw new CryptoFailedException("Decryption failed for alias: " + alias, fail);
-    }
-  }
-
-  /** redirect call to default {@link #decrypt(String, byte[], byte[], SecurityLevel)} method. */
-  @Override
-  public void decrypt(@NonNull DecryptionResultHandler handler,
-                      @NonNull String service,
-                      @NonNull byte[] username,
-                      @NonNull byte[] password,
-                      @NonNull final SecurityLevel level) {
-
-    try {
-      final DecryptionResult results = decrypt(service, username, password, level);
-
-      handler.onDecrypt(results, null);
-    } catch (Throwable fail) {
-      handler.onDecrypt(null, fail);
-    }
-  }
-
-  @Override
-  public void removeKey(@NonNull final String alias) {
-    // Facebook Conceal stores only one key across all services, so we cannot
-    // delete the key (otherwise decryption will fail for encrypted data of other services).
-    Log.w(LOG_TAG, "CipherStorageFacebookConceal removeKey called. alias: " + alias);
-  }
-
-  @NonNull
-  @Override
-  protected KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias)
-    throws GeneralSecurityException {
-    throw new CryptoFailedException("Not designed for a call");
-  }
-
-  @NonNull
-  @Override
-  protected KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias, @NonNull final boolean isForTesting)
-    throws GeneralSecurityException {
-    throw new CryptoFailedException("Not designed for a call");
-  }
-
-  @NonNull
-  @Override
-  protected KeyInfo getKeyInfo(@NonNull final Key key) throws GeneralSecurityException {
-    throw new CryptoFailedException("Not designed for a call");
-  }
-
-  @NonNull
-  @Override
-  protected Key generateKey(@NonNull final KeyGenParameterSpec spec) throws GeneralSecurityException {
-    throw new CryptoFailedException("Not designed for a call");
-  }
-
-  @NonNull
-  @Override
-  protected String getEncryptionAlgorithm() {
-    throw new AssertionException("Not designed for a call");
-  }
-
-  @NonNull
-  @Override
-  protected String getEncryptionTransformation() {
-    throw new AssertionException("Not designed for a call");
-  }
-
-  /** Verify availability of the Crypto API. */
-  private void throwIfNoCryptoAvailable() throws CryptoFailedException {
-    if (!crypto.isAvailable()) {
-      throw new CryptoFailedException("Crypto is missing");
-    }
-  }
-  //endregion
-
-  //region Helper methods
-  @NonNull
-  private static Entity createUsernameEntity(@NonNull final String alias) {
-    final String prefix = getEntityPrefix(alias);
-
-    return Entity.create(prefix + "user");
-  }
-
-  @NonNull
-  private static Entity createPasswordEntity(@NonNull final String alias) {
-    final String prefix = getEntityPrefix(alias);
-
-    return Entity.create(prefix + "pass");
-  }
-
-  @NonNull
-  private static String getEntityPrefix(@NonNull final String alias) {
-    return KEYCHAIN_DATA + ":" + alias;
-  }
-  //endregion
-}
diff --git a/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesCbc.java b/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesCbc.java
index 7dbcc8b8645e9394a38575e3a2cea5b77225ee70..36d8ad00c40dc6b97a08ff8e852cf21179898300 100644
--- a/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesCbc.java
+++ b/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesCbc.java
@@ -12,6 +12,10 @@ import androidx.annotation.Nullable;
 
 import com.oblador.keychain.KeychainModule.KnownCiphers;
 import com.oblador.keychain.SecurityLevel;
+import com.oblador.keychain.cipherStorage.CipherStorage.DecryptionResult;
+import com.oblador.keychain.cipherStorage.CipherStorage.EncryptionResult;
+import com.oblador.keychain.cipherStorage.CipherStorageBase.DecryptBytesHandler;
+import com.oblador.keychain.cipherStorage.CipherStorageBase.IV;
 import com.oblador.keychain.decryptionHandler.DecryptionResultHandler;
 import com.oblador.keychain.exceptions.CryptoFailedException;
 import com.oblador.keychain.exceptions.KeyStoreAccessException;
@@ -49,6 +53,8 @@ public class CipherStorageKeystoreAesCbc extends CipherStorageBase {
   public static final int ENCRYPTION_KEY_SIZE = 256;
 
   public static final String DEFAULT_SERVICE = "RN_KEYCHAIN_DEFAULT_ALIAS";
+
+  String DEVICE_PASSCODE = "DevicePasscode";
   //endregion
 
   //region Configuration
@@ -103,7 +109,8 @@ public class CipherStorageKeystoreAesCbc extends CipherStorageBase {
   public EncryptionResult encrypt(@NonNull final String alias,
                                   @NonNull final String username,
                                   @NonNull final String password,
-                                  @NonNull final SecurityLevel level)
+                                  @NonNull final SecurityLevel level,
+                                  String accessControl)
     throws CryptoFailedException {
 
     throwIfInsufficientLevel(level);
@@ -111,8 +118,10 @@ public class CipherStorageKeystoreAesCbc extends CipherStorageBase {
     final String safeAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName());
     final AtomicInteger retries = new AtomicInteger(1);
 
+    Boolean requireAuthentication = accessControl != null && accessControl.contains(DEVICE_PASSCODE);
+
     try {
-      final Key key = extractGeneratedKey(safeAlias, level, retries);
+      final Key key = extractGeneratedKey(safeAlias, level, retries, requireAuthentication);
 
       return new EncryptionResult(
         encryptString(key, username),
@@ -140,7 +149,7 @@ public class CipherStorageKeystoreAesCbc extends CipherStorageBase {
     final AtomicInteger retries = new AtomicInteger(1);
 
     try {
-      final Key key = extractGeneratedKey(safeAlias, level, retries);
+      final Key key = extractGeneratedKey(safeAlias, level, retries, false);
 
       return new DecryptionResult(
         decryptBytes(key, username),
@@ -176,14 +185,14 @@ public class CipherStorageKeystoreAesCbc extends CipherStorageBase {
   /** Get builder for encryption and decryption operations with required user Authentication. */
   @NonNull
   @Override
-  protected KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias) throws GeneralSecurityException {
-    return getKeyGenSpecBuilder(alias, false);
+  protected KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias, Boolean requireAuthentication) throws GeneralSecurityException {
+    return getKeyGenSpecBuilder(alias, false, requireAuthentication);
   }
 
   /** Get encryption algorithm specification builder instance. */
   @NonNull
   @Override
-  protected KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias, @NonNull final boolean isForTesting)
+  protected KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias, @NonNull final boolean isForTesting, Boolean requireAuthentication)
     throws GeneralSecurityException {
     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
       throw new KeyStoreAccessException("Unsupported API" + Build.VERSION.SDK_INT + " version detected.");
@@ -194,7 +203,8 @@ public class CipherStorageKeystoreAesCbc extends CipherStorageBase {
     return new KeyGenParameterSpec.Builder(alias, purposes)
       .setBlockModes(BLOCK_MODE_CBC)
       .setEncryptionPaddings(PADDING_PKCS7)
-      .setRandomizedEncryptionRequired(true)
+      .setRandomizedEncryptionRequired(requireAuthentication)
+      .setUserAuthenticationValidityDurationSeconds(1)
       .setKeySize(ENCRYPTION_KEY_SIZE);
   }
 
diff --git a/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.java b/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.java
index 5603fbf0effdb1be891eb92cf4152494f2b49b26..821e4b66b87dbaaff55d5995fa7a17507e5f6a75 100644
--- a/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.java
+++ b/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.java
@@ -13,6 +13,9 @@ import androidx.annotation.RequiresApi;
 
 import com.oblador.keychain.KeychainModule;
 import com.oblador.keychain.SecurityLevel;
+import com.oblador.keychain.cipherStorage.CipherStorage.DecryptionContext;
+import com.oblador.keychain.cipherStorage.CipherStorage.DecryptionResult;
+import com.oblador.keychain.cipherStorage.CipherStorage.EncryptionResult;
 import com.oblador.keychain.decryptionHandler.DecryptionResultHandler;
 import com.oblador.keychain.decryptionHandler.DecryptionResultHandlerNonInteractive;
 import com.oblador.keychain.exceptions.CryptoFailedException;
@@ -61,7 +64,8 @@ public class CipherStorageKeystoreRsaEcb extends CipherStorageBase {
   public EncryptionResult encrypt(@NonNull final String alias,
                                   @NonNull final String username,
                                   @NonNull final String password,
-                                  @NonNull final SecurityLevel level)
+                                  @NonNull final SecurityLevel level,
+                                  String accessControl)
     throws CryptoFailedException {
 
     throwIfInsufficientLevel(level);
@@ -122,17 +126,7 @@ public class CipherStorageKeystoreRsaEcb extends CipherStorageBase {
     Key key = null;
 
     try {
-      // key is always NOT NULL otherwise GeneralSecurityException raised
-      key = extractGeneratedKey(safeAlias, level, retries);
-
-      final DecryptionResult results = new DecryptionResult(
-        decryptBytes(key, username),
-        decryptBytes(key, password)
-      );
-
-      handler.onDecrypt(results, null);
-    } catch (final UserNotAuthenticatedException ex) {
-      Log.d(LOG_TAG, "Unlock of keystore is needed. Error: " + ex.getMessage(), ex);
+      key = extractGeneratedKey(safeAlias, level, retries, false);
 
       // expected that KEY instance is extracted and we caught exception on decryptBytes operation
       @SuppressWarnings("ConstantConditions") final DecryptionContext context =
@@ -196,7 +190,7 @@ public class CipherStorageKeystoreRsaEcb extends CipherStorageBase {
 
     // on first access create a key for storage
     if (!store.containsAlias(alias)) {
-      generateKeyAndStoreUnderAlias(alias, level);
+      generateKeyAndStoreUnderAlias(alias, level, false);
     }
 
     final KeyFactory kf = KeyFactory.getInstance(ALGORITHM_RSA);
@@ -215,15 +209,15 @@ public class CipherStorageKeystoreRsaEcb extends CipherStorageBase {
   @NonNull
   @Override
   @SuppressLint("NewApi")
-  protected KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias) throws GeneralSecurityException{
-    return getKeyGenSpecBuilder(alias, false);
+  protected KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias, Boolean requireAuthentication) throws GeneralSecurityException{
+    return getKeyGenSpecBuilder(alias, false, requireAuthentication);
   }
 
   /** Get builder for encryption and decryption operations with required user Authentication. */
   @NonNull
   @Override
   @SuppressLint("NewApi")
-  protected KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias, @NonNull final boolean isForTesting)
+  protected KeyGenParameterSpec.Builder getKeyGenSpecBuilder(@NonNull final String alias, @NonNull final boolean isForTesting, Boolean requireAuthentication)
     throws GeneralSecurityException {
     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
       throw new KeyStoreAccessException("Unsupported API" + Build.VERSION.SDK_INT + " version detected.");
@@ -233,12 +227,12 @@ public class CipherStorageKeystoreRsaEcb extends CipherStorageBase {
 
     final int keySize = isForTesting ? ENCRYPTION_KEY_SIZE_WHEN_TESTING : ENCRYPTION_KEY_SIZE;
 
-    final int validityDuration = 5;
+    final int validityDuration = 1;
     final KeyGenParameterSpec.Builder keyGenParameterSpecBuilder = new KeyGenParameterSpec.Builder(alias, purposes)
       .setBlockModes(BLOCK_MODE_ECB)
       .setEncryptionPaddings(PADDING_PKCS1)
       .setRandomizedEncryptionRequired(true)
-      .setUserAuthenticationRequired(true)
+      .setUserAuthenticationRequired(requireAuthentication)
       .setKeySize(keySize);
 
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
