diff --git a/index.js b/index.js
index f79318c817c35ea977ac4e51dbfb06ce25055832..38f490efb4c29b05c9ad5166438c32c731751a8c 100644
--- a/index.js
+++ b/index.js
@@ -3,11 +3,15 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
 /*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
 const _assert_1 = require("@noble/hashes/_assert");
-const pbkdf2_1 = require("@noble/hashes/pbkdf2");
+// const pbkdf2_1 = require("@noble/hashes/pbkdf2");
 const sha256_1 = require("@noble/hashes/sha256");
-const sha512_1 = require("@noble/hashes/sha512");
+// const sha512_1 = require("@noble/hashes/sha512");
 const utils_1 = require("@noble/hashes/utils");
 const base_1 = require("@scure/base");
+const import_wordlist_en = require("./wordlists/english")
+const react_native_quick_crypto = require("react-native-quick-crypto");
+const react_native_buffer = require("@craftzdog/react-native-buffer");
+
 // Japanese wordlist
 const isJapanese = (wordlist) => wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093';
 // Normalization replaces equivalent sequences of characters
@@ -74,8 +78,16 @@ function getCoder(wordlist) {
  * ])
  */
 function mnemonicToEntropy(mnemonic, wordlist) {
-    const { words } = normalize(mnemonic);
-    const entropy = getCoder(wordlist).decode(words);
+    let entropy;
+    if (typeof mnemonic === 'string') {
+        const { words } = normalize(mnemonic);
+        entropy = getCoder(wordlist).decode(words);
+    } else {
+        // expected intanceOf Uint8Array when used with eth-hd-keyring
+        entropy = getCoder(wordlist).decode(
+            Array.from(new Uint16Array(mnemonic.buffer)).map((i) => wordlist[i])
+        );
+    }
     assertEntropy(entropy);
     return entropy;
 }
@@ -96,7 +108,12 @@ exports.mnemonicToEntropy = mnemonicToEntropy;
 function entropyToMnemonic(entropy, wordlist) {
     assertEntropy(entropy);
     const words = getCoder(wordlist).encode(entropy);
+
     return words.join(isJapanese(wordlist) ? '\u3000' : ' ');
+
+    // const indices = words.map((word) => wordlist.indexOf(word));
+    // const uInt8ArrayOfMnemonic = new Uint8Array(new Uint16Array(indices).buffer);
+    // return uInt8ArrayOfMnemonic;
 }
 exports.entropyToMnemonic = entropyToMnemonic;
 /**
@@ -123,8 +140,12 @@ const salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
  * await mnemonicToSeed(mnem, 'password');
  * // new Uint8Array([...64 bytes])
  */
-function mnemonicToSeed(mnemonic, passphrase = '') {
-    return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
+async function mnemonicToSeed(mnemonic, passphrase = '') {
+    // const encodedMnemonicUint8Array = encodeMnemonicForSeedDerivation(mnemonic, wordlist);
+    // return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, encodedMnemonicUint8Array, salt(passphrase), { c: 2048, dkLen: 64 });
+    const mnemonicBuffer = new react_native_buffer.Buffer(mnemonic, "utf8");
+    const saltBuffer = new react_native_buffer.Buffer(salt(passphrase), "utf8");
+    return react_native_quick_crypto.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, "sha512");
 }
 exports.mnemonicToSeed = mnemonicToSeed;
 /**
@@ -138,6 +159,27 @@ exports.mnemonicToSeed = mnemonicToSeed;
  * // new Uint8Array([...64 bytes])
  */
 function mnemonicToSeedSync(mnemonic, passphrase = '') {
-    return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
+    // const encodedMnemonicUint8Array = encodeMnemonicForSeedDerivation(mnemonic, wordlist);
+    // return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, encodedMnemonicUint8Array, salt(passphrase), { c: 2048, dkLen: 64 });
+    const mnemonicBuffer = new react_native_buffer.Buffer(mnemonic, "utf8");
+    const saltBuffer = new react_native_buffer.Buffer(salt(passphrase), "utf8");
+    return react_native_quick_crypto.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, "sha512");
 }
 exports.mnemonicToSeedSync = mnemonicToSeedSync;
+
+/**
+ * Helper function to encode mnemonic passed either as a string or `Uint8Array` for deriving a seed/key with pbkdf2.
+ */
+function encodeMnemonicForSeedDerivation(mnemonic, wordlist = import_wordlist_en.wordlist) {
+  let encodedMnemonicUint8Array;
+  if (typeof mnemonic === 'string') {
+    encodedMnemonicUint8Array = new TextEncoder().encode(normalize(mnemonic).nfkd);
+  } else {
+    encodedMnemonicUint8Array = new TextEncoder().encode(
+      Array.from(new Uint16Array(mnemonic.buffer))
+        .map((i) => wordlist[i])
+        .join(' ')
+    );
+  }
+  return encodedMnemonicUint8Array;
+}
